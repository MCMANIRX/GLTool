package GLTTool;


import java.awt.Graphics;
import java.awt.Image;

import java.awt.image.BufferedImage;

import java.io.File;

import java.io.IOException;

import java.util.ArrayList;
import java.util.Arrays;


import javax.imageio.ImageIO;

public class encTest {
	


	 public static int dx;
	 public static int dy;
	 static BufferedImage in;
	 static BufferedImage mip;
	 public static int lod;
	 public static int wh;
	 
	 
	 static short[] cc85 = {
		    0x00,0x00,0x00,0x00, 0x00,0x01,0x01,0x01, 0x01,0x01,0x01,0x01, 0x01,0x02,0x02,0x02,
		    0x02,0x02,0x02,0x02, 0x02,0x03,0x03,0x03, 0x03,0x03,0x03,0x03, 0x03,0x04,0x04,0x04,
		    0x04,0x04,0x04,0x04, 0x04,0x04,0x05,0x05, 0x05,0x05,0x05,0x05, 0x05,0x05,0x06,0x06,
		    0x06,0x06,0x06,0x06, 0x06,0x06,0x07,0x07, 0x07,0x07,0x07,0x07, 0x07,0x07,0x08,0x08,
		    0x08,0x08,0x08,0x08, 0x08,0x08,0x09,0x09, 0x09,0x09,0x09,0x09, 0x09,0x09,0x09,0x0a,
		    0x0a,0x0a,0x0a,0x0a, 0x0a,0x0a,0x0a,0x0b, 0x0b,0x0b,0x0b,0x0b, 0x0b,0x0b,0x0b,0x0c,
		    0x0c,0x0c,0x0c,0x0c, 0x0c,0x0c,0x0c,0x0d, 0x0d,0x0d,0x0d,0x0d, 0x0d,0x0d,0x0d,0x0d,
		    0x0e,0x0e,0x0e,0x0e, 0x0e,0x0e,0x0e,0x0e, 0x0f,0x0f,0x0f,0x0f, 0x0f,0x0f,0x0f,0x0f,
		    0x10,0x10,0x10,0x10, 0x10,0x10,0x10,0x10, 0x11,0x11,0x11,0x11, 0x11,0x11,0x11,0x11,
		    0x12,0x12,0x12,0x12, 0x12,0x12,0x12,0x12, 0x12,0x13,0x13,0x13, 0x13,0x13,0x13,0x13,
		    0x13,0x14,0x14,0x14, 0x14,0x14,0x14,0x14, 0x14,0x15,0x15,0x15, 0x15,0x15,0x15,0x15,
		    0x15,0x16,0x16,0x16, 0x16,0x16,0x16,0x16, 0x16,0x16,0x17,0x17, 0x17,0x17,0x17,0x17,
		    0x17,0x17,0x18,0x18, 0x18,0x18,0x18,0x18, 0x18,0x18,0x19,0x19, 0x19,0x19,0x19,0x19,
		    0x19,0x19,0x1a,0x1a, 0x1a,0x1a,0x1a,0x1a, 0x1a,0x1a,0x1b,0x1b, 0x1b,0x1b,0x1b,0x1b,
		    0x1b,0x1b,0x1b,0x1c, 0x1c,0x1c,0x1c,0x1c, 0x1c,0x1c,0x1c,0x1d, 0x1d,0x1d,0x1d,0x1d,
		    0x1d,0x1d,0x1d,0x1e, 0x1e,0x1e,0x1e,0x1e, 0x1e,0x1e,0x1e,0x1f, 0x1f,0x1f,0x1f,0x1f
		};
	 
	 static short[] cc86 = {
			    0x00,0x00,0x00,0x01, 0x01,0x01,0x01,0x02, 0x02,0x02,0x02,0x03, 0x03,0x03,0x03,0x04,
			    0x04,0x04,0x04,0x05, 0x05,0x05,0x05,0x06, 0x06,0x06,0x06,0x07, 0x07,0x07,0x07,0x08,
			    0x08,0x08,0x08,0x09, 0x09,0x09,0x09,0x0a, 0x0a,0x0a,0x0a,0x0b, 0x0b,0x0b,0x0b,0x0c,
			    0x0c,0x0c,0x0c,0x0d, 0x0d,0x0d,0x0d,0x0e, 0x0e,0x0e,0x0e,0x0f, 0x0f,0x0f,0x0f,0x10,
			    0x10,0x10,0x10,0x11, 0x11,0x11,0x11,0x12, 0x12,0x12,0x12,0x13, 0x13,0x13,0x13,0x14,
			    0x14,0x14,0x14,0x15, 0x15,0x15,0x15,0x15, 0x16,0x16,0x16,0x16, 0x17,0x17,0x17,0x17,
			    0x18,0x18,0x18,0x18, 0x19,0x19,0x19,0x19, 0x1a,0x1a,0x1a,0x1a, 0x1b,0x1b,0x1b,0x1b,
			    0x1c,0x1c,0x1c,0x1c, 0x1d,0x1d,0x1d,0x1d, 0x1e,0x1e,0x1e,0x1e, 0x1f,0x1f,0x1f,0x1f,
			    0x20,0x20,0x20,0x20, 0x21,0x21,0x21,0x21, 0x22,0x22,0x22,0x22, 0x23,0x23,0x23,0x23,
			    0x24,0x24,0x24,0x24, 0x25,0x25,0x25,0x25, 0x26,0x26,0x26,0x26, 0x27,0x27,0x27,0x27,
			    0x28,0x28,0x28,0x28, 0x29,0x29,0x29,0x29, 0x2a,0x2a,0x2a,0x2a, 0x2a,0x2b,0x2b,0x2b,
			    0x2b,0x2c,0x2c,0x2c, 0x2c,0x2d,0x2d,0x2d, 0x2d,0x2e,0x2e,0x2e, 0x2e,0x2f,0x2f,0x2f,
			    0x2f,0x30,0x30,0x30, 0x30,0x31,0x31,0x31, 0x31,0x32,0x32,0x32, 0x32,0x33,0x33,0x33,
			    0x33,0x34,0x34,0x34, 0x34,0x35,0x35,0x35, 0x35,0x36,0x36,0x36, 0x36,0x37,0x37,0x37,
			    0x37,0x38,0x38,0x38, 0x38,0x39,0x39,0x39, 0x39,0x3a,0x3a,0x3a, 0x3a,0x3b,0x3b,0x3b,
			    0x3b,0x3c,0x3c,0x3c, 0x3c,0x3d,0x3d,0x3d, 0x3d,0x3e,0x3e,0x3e, 0x3e,0x3f,0x3f,0x3f
			};
	 
	 private static short[] cc83 = // convert 8-bit color to 3-bit color
	     {
	         0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	         0x00,0x00,0x00,0x01, 0x01,0x01,0x01,0x01, 0x01,0x01,0x01,0x01, 0x01,0x01,0x01,0x01,
	         0x01,0x01,0x01,0x01, 0x01,0x01,0x01,0x01, 0x01,0x01,0x01,0x01, 0x01,0x01,0x01,0x01,
	         0x01,0x01,0x01,0x01, 0x01,0x01,0x01,0x02, 0x02,0x02,0x02,0x02, 0x02,0x02,0x02,0x02,
	         0x02,0x02,0x02,0x02, 0x02,0x02,0x02,0x02, 0x02,0x02,0x02,0x02, 0x02,0x02,0x02,0x02,
	         0x02,0x02,0x02,0x02, 0x02,0x02,0x02,0x02, 0x02,0x02,0x02,0x02, 0x03,0x03,0x03,0x03,
	         0x03,0x03,0x03,0x03, 0x03,0x03,0x03,0x03, 0x03,0x03,0x03,0x03, 0x03,0x03,0x03,0x03,
	         0x03,0x03,0x03,0x03, 0x03,0x03,0x03,0x03, 0x03,0x03,0x03,0x03, 0x03,0x03,0x03,0x03,
	         0x04,0x04,0x04,0x04, 0x04,0x04,0x04,0x04, 0x04,0x04,0x04,0x04, 0x04,0x04,0x04,0x04,
	         0x04,0x04,0x04,0x04, 0x04,0x04,0x04,0x04, 0x04,0x04,0x04,0x04, 0x04,0x04,0x04,0x04,
	         0x04,0x04,0x04,0x04, 0x05,0x05,0x05,0x05, 0x05,0x05,0x05,0x05, 0x05,0x05,0x05,0x05,
	         0x05,0x05,0x05,0x05, 0x05,0x05,0x05,0x05, 0x05,0x05,0x05,0x05, 0x05,0x05,0x05,0x05,
	         0x05,0x05,0x05,0x05, 0x05,0x05,0x05,0x05, 0x05,0x06,0x06,0x06, 0x06,0x06,0x06,0x06,
	         0x06,0x06,0x06,0x06, 0x06,0x06,0x06,0x06, 0x06,0x06,0x06,0x06, 0x06,0x06,0x06,0x06,
	         0x06,0x06,0x06,0x06, 0x06,0x06,0x06,0x06, 0x06,0x06,0x06,0x06, 0x06,0x07,0x07,0x07,
	         0x07,0x07,0x07,0x07, 0x07,0x07,0x07,0x07, 0x07,0x07,0x07,0x07, 0x07,0x07,0x07,0x07
	     };

	     private static short[] cc84 = // convert 8-bit color to 4-bit color
	     {
	         0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x01,0x01,0x01, 0x01,0x01,0x01,0x01,
	         0x01,0x01,0x01,0x01, 0x01,0x01,0x01,0x01, 0x01,0x01,0x02,0x02, 0x02,0x02,0x02,0x02,
	         0x02,0x02,0x02,0x02, 0x02,0x02,0x02,0x02, 0x02,0x02,0x02,0x03, 0x03,0x03,0x03,0x03,
	         0x03,0x03,0x03,0x03, 0x03,0x03,0x03,0x03, 0x03,0x03,0x03,0x03, 0x04,0x04,0x04,0x04,
	         0x04,0x04,0x04,0x04, 0x04,0x04,0x04,0x04, 0x04,0x04,0x04,0x04, 0x04,0x05,0x05,0x05,
	         0x05,0x05,0x05,0x05, 0x05,0x05,0x05,0x05, 0x05,0x05,0x05,0x05, 0x05,0x05,0x06,0x06,
	         0x06,0x06,0x06,0x06, 0x06,0x06,0x06,0x06, 0x06,0x06,0x06,0x06, 0x06,0x06,0x06,0x07,
	         0x07,0x07,0x07,0x07, 0x07,0x07,0x07,0x07, 0x07,0x07,0x07,0x07, 0x07,0x07,0x07,0x07,
	         0x08,0x08,0x08,0x08, 0x08,0x08,0x08,0x08, 0x08,0x08,0x08,0x08, 0x08,0x08,0x08,0x08,
	         0x08,0x09,0x09,0x09, 0x09,0x09,0x09,0x09, 0x09,0x09,0x09,0x09, 0x09,0x09,0x09,0x09,
	         0x09,0x09,0x0a,0x0a, 0x0a,0x0a,0x0a,0x0a, 0x0a,0x0a,0x0a,0x0a, 0x0a,0x0a,0x0a,0x0a,
	         0x0a,0x0a,0x0a,0x0b, 0x0b,0x0b,0x0b,0x0b, 0x0b,0x0b,0x0b,0x0b, 0x0b,0x0b,0x0b,0x0b,
	         0x0b,0x0b,0x0b,0x0b, 0x0c,0x0c,0x0c,0x0c, 0x0c,0x0c,0x0c,0x0c, 0x0c,0x0c,0x0c,0x0c,
	         0x0c,0x0c,0x0c,0x0c, 0x0c,0x0d,0x0d,0x0d, 0x0d,0x0d,0x0d,0x0d, 0x0d,0x0d,0x0d,0x0d,
	         0x0d,0x0d,0x0d,0x0d, 0x0d,0x0d,0x0e,0x0e, 0x0e,0x0e,0x0e,0x0e, 0x0e,0x0e,0x0e,0x0e,
	         0x0e,0x0e,0x0e,0x0e, 0x0e,0x0e,0x0e,0x0f, 0x0f,0x0f,0x0f,0x0f, 0x0f,0x0f,0x0f,0x0f
	     };
	 
	 public static byte[] getTex(File f,byte et) throws IOException  {
		 
		 
		 
		 	ArrayList<Byte> buf = new ArrayList<Byte>();
		 	
	 		in = ImageIO.read(f);
		 
		 	int h = in.getHeight();
	 		int w = in.getWidth();
	 		
	 		wh = (w<<16) | h &0xFFFF;
	 		
	 		//calculate amount of mipmaps to generate
	 		 lod = cntMips(h,w);
	 		
	 		main.p("encoding tex "+main.index+" ("+lod+" generated mipmaps)");
	 			 		
	 		
	 		//encode original image + generated mipmaps
	 		for(int i = 0; i < lod; ++i) {
	 			
	 			
	 			
	 	 		int ww = (int)Math.round(w/(Math.pow(2,i)));
	 	 		int hh = (int)Math.round(h/(Math.pow(2,i)));
	 		
		 		
	 		 Image img = in.getScaledInstance(ww, hh, Image.SCALE_REPLICATE); //scale down Image for mipmap
	 		 
	 		 mip = itbi(img); //Image to BufferedImage
	 		 
	 		 
	 		switch(et) {
			
			case 0x5:
				buf.addAll(enc5a3(ww,hh));
			
			case 0x6:
			    buf.addAll(encCmpr(ww,hh));
				break;
			
			case 0x8:
			    buf.addAll(encRgb8(ww,hh));
				break;
				
			default:
				p("\""+et+"\" is an unknown encoding type. defaulting to CMPR");
				buf.addAll(encCmpr(ww,hh));
				break;
			
			}
	 		 
	 		

			 
			 
		 }
	 		
	 	Byte[] b = buf.toArray(new Byte[buf.size()]);
	 	
	 	byte[] ret = new byte[b.length];
	 	
		
	 	for(int i = 0 ; i <b.length; ++i)
	 		ret[i] = b[i];
	 	

	 	
	 	return ret;
		 
	 }
	 
			
	 public static ArrayList<Byte> encCmpr(int w, int h) throws IOException {

	 		  
	 		 ArrayList<Byte> img = new ArrayList<Byte>();



	 	/*	byte[] pix  = ((DataBufferByte) in.getRaster().getDataBuffer()).getData();
	 		  
	 		  int pixl = ((pix[0] & 255) << 24 )|(( pix[1] & 255) << 16) | (pix[2] & 255) <<8 | pix[3] & 255;
	 		  
	 		 */
	 		int x = 0;
	 		int y = 0;
	 		int dx = 0;
	 		int dy = 0;
	 		
	 		int dyHack = 0;
	 		
	 	while(y<h-4) {
	 			
	 		
	 		
	 		if(dx>=8) {
	 			
	 			if(dyHack == x)
	 				dy=4;
	 			else dy = 0;
	 			
	 			dx=0;
	 			
	 		}
	 		
	 		int[] texel = new int[16];
	 		
	 		
	 		
	 		long CMPRTexel = ARGB2CMPR(texel,dx,dy,x,y);
	 		
	 		//append each byte of the 8-byte texel to the ArrayList one at a time
	 		for(int k = 0 ; k < 8; ++k)
	 			img.add((byte) (( (CMPRTexel>>56-(8*k)) )&0xFF  )) ;
	 		
	 		
	 		
	 	 	//System.out.println("x: "+x+" y: "+y+" dx: "+dx+" dy: "+dy);
	 		dyHack = x;
	 		if(dx == 4 && dy == 4)  { x+=8;}
	 		
	 		
	 		dx+=4;
	 		
	 		if(x>w-4) {
	 			x= 0 ;
	 			y+=8;
	 		}
	 		
	 		
	 		
	 		}	 	
	 	
	 	
	 	return img;
	 		 	

	 }
	 


private static long ARGB2CMPR(int[] texel, int pdx, int pdy, int x, int y){
		
		
		
	  mip.getRGB(x+pdx, y+pdy, 4, 4, texel, 0, 4); 
	  
	  int[] pal = getPalette(texel);
		
	  int ind32  = getIndicies(texel, pal);
	  
	  int c0c1 = to565(pal);
	  
	  return (((long)c0c1) << 32) | (ind32 & 0xffffffffL); //1 CMPR block (texel)
	  
		
		
	}
	


public static int[] getPalette(int[] pix) {
	
	int[] pal = new int[4];
	
	//extremes (c0,c1)
	pal[0] = Arrays.stream(pix).max().getAsInt(); 
	pal[1] = Arrays.stream(pix).min().getAsInt();
	
	//avgs (c2, c3)
	pal[2] = ((2*pal[0]+pal[1])/3);
	pal[3] = ((pal[0]+2*pal[1])/3);
	

    

	
	return pal;
	
	
}

public static int getIndicies(int[] texel, int[] pal) {
	
	int[] ind = new int[16];
	
	int ind32 = 0;
	
	//determine indices into the 4 color palette by finding the numerically closest color in the palette to a given pixel's color
    
    for(int i = 0 ; i <texel.length; ++i) 
    		ind[i] = closest(texel[i],pal); 
    

     //convert indices to u32
    for(int i = 0; i < ind.length; ++i)
    	ind32 += ((ind[i]& 3) << 30-(2*i)) ;
    
	return ind32;
}
	//ARGB888 to RGB565
private static int to565(int[] te) {
	
	
	boolean alpha = false;
	
	int[] t565 = new int[te.length];
	
	int ret565 = 0;
	
	
	for(int i = 0; i < te.length; ++i) {
		
		
		
		if( ((te[i]>>24) &0xFF) <=0x80 ) //if not mildly opaque,  considered transparent
			alpha = true;
		
		
		t565[i] = 
						cc85[ te[i] >> 16 & 0xff ] << 11
			    		| cc86[ te[i] >>  8 & 0xff ] <<  5
			    		| cc85[ te[i]       & 0xff ];
			    	
	}
	
	//logic for writing c0 and c1
	int big=0;
	int smol =0;
	
	if(t565[0] >= t565[1]) {
			big = t565[0];
			smol = t565[1];
			
	} else {big = t565[1]; smol = t565[0]; }
	
	
	//	ret565 = (big & 0xFFFF) << 16 | (smol & 0xFFFF);
	if(alpha)
		ret565 = (smol & 0xFFFF) << 16 | (big+1 & 0xFFFF);	// add +1 because if c0 < c1, the texel has alpha transparency
	else
		ret565 = (big & 0xFFFF) << 16 | (smol & 0xFFFF);
	

	
		return ret565;
	
}

public static ArrayList<Byte> enc5a3 (int w, int h) throws IOException {
	
	ArrayList<Byte> img = new ArrayList<Byte>();
	
	 
	 int y = 0;
	 int x =0;

	 int[] texel = new int[16];
	 
	 
		while(y<h) {

			
			 
			  mip.getRGB(x, y, 4, 4, texel, 0, 4);
			  


			  	//gnerate and add texels to ArratList byte by byte
			 for(int i = 0; i < texel.length; ++i) {
					int pix = ( (texel[i] >> 24) & 0xFF) == 0xFF ? a888toRGB(texel[i], false) : a888toRGB(texel[i], true);
			
					for(int k = 0; k < 2 ; ++k) 
						img.add( (byte) ((pix >> (8-(k*8))) &0xFF) );
			 }

	 	System.out.println("X: "+x+" Y: "+y+" dx: "+dx+" dy: "+dy);

		 	
	 		x+= 4;
		    if(x >= w) {
	            x = 0;
	            y += 4;
	        
	    }
	 		
	 		
	 		
	 		

	 
	 
}
		
		return img;
		

}

public static ArrayList<Byte> encRgb8 (int w, int h) throws IOException {
	
	ArrayList<Byte> img = new ArrayList<Byte>();
	
	 
	 int y = 0;
	 int x = 0;

	
	 
	 
		while(y<h) {

			
			 

			 int[] texel = new int[16];	
			 
			  mip.getRGB(x, y, 4, 4, texel, 0, 4);

			 
			 for(int i = 0; i < texel.length ; ++i) {
				// pint(texel[i]);
				 img.add( (byte) ((texel[i]>>24)&0xFF)); 
				 img.add( (byte) ((texel[i]>>16)&0xFF)); 
			 }//AR
			 
			 for(int i = 0; i < texel.length ; ++i) {
				 img.add( (byte) ((texel[i]>>8)&0xFF)); 
				 img.add( (byte) ((texel[i])&0xFF));
			 }//GB

		 	
	 		x+= 4;
		    if(x >= w) {
	            x = 0;
	            y += 4;
	        
	    }
	 		
	 		
	 		
	 		

	 
	 
}
		
		return img;
		

}

public static int a888toRGB(int c, boolean alpha) {
	 
	 int a;
	 int r;
	 int g;
	 int b;
	 
	 int ret =0;
	 
	 
	if(!alpha) {
		 a= 0x1;
		 r = cc85[(c>>16)&0xff];
		 g = cc85[(c>>8)&0xff];
		 b = cc85[c&0xff];
		 
		 ret = (a<<15) | r <<10 | g<<5 | b;
	}
	
	else {
		 
		 a= cc83[(c>>24)&0xff];
		 r = cc84[(c>>16)&0xff];
		 g = cc84[(c>>8)&0xff];
		 b = cc84[c&0xff];
		 
		 ret = (0x0 << 15)&0x7 | a<< 12 | r <<8 | g<<4 | b;
		// pint(ret);
			//System.exit(0);
	}
		
	
	// System.out.println(Integer.toBinaryString(ret));

		return ret; 
		 
	 }
	

	
	
	
	
	 public static void p(String txt) {
			
			System.out.println(txt);
		}
		
	public static void pint(int txt) {
			
			System.out.println(Integer.toHexString(txt)+" ");
		}
	public static void pb(int txt) {
		
		System.out.println(Integer.toBinaryString(txt));
	}



	public static int closest(int find, int[] values) {
		
		
	    int closest = Integer.MAX_VALUE;
	    int temp= 0 ;
	    int temp1 = Integer.MAX_VALUE;
	    int ci = 0;
	    
	    if( ((find>>24) &0xFF) !=0xFF )
	    	return 3;
	    
	    for(int i = 0; i<values.length; ++i) { 
	    	
    		/*if(temp1 < closest) {
    			closest = values[i-1];
    			ci = i-1;
    			
    		}*/
    		
	    	temp = Math.abs(find - values[i]);
	    		if(temp < closest) {
	    			closest = temp;
	    			ci = i;
	    		}
	    	temp1 = temp;
	    }
	        
	    return ci;
	} 
	
	//convert to BufferedImage 
	public static BufferedImage itbi(Image im) {
	     BufferedImage bi = new BufferedImage
	        (im.getWidth(null),im.getHeight(null),BufferedImage.TYPE_INT_ARGB);
	     Graphics bg = bi.getGraphics();
	     bg.drawImage(im, 0, 0, null);
	     bg.dispose();
	     return bi;
	  }
	
	//determine limiting dimension to generate max mips
	public static int cntMips(int h, int w) {
		
		int hl = 0;
		int wl = 0;
		
		int l = 0;
		
		int temp = h;
		
		while(temp>=16) {
			temp = temp/2;
			++hl;				
		}
		
		temp = w;
		
		while(temp>=16) {
			temp = temp/2;
			++wl;				
		}
		
		if(hl>wl)
			l = wl;
		else l = hl;
		
		
		
		return l;
	}



	

}//end class

	


